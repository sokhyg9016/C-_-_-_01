# C++ Primer Plus (6th Edition)
This site was built using [GitHub Pages](https://pages.github.com/).

1. **Reference**: <a href="https://isocpp.org/" target="_blank">`https://isocpp.org/`</a>
1. **Date**: 2019.12.18
1. **Topic**: 데이터 처리 (p.71 ~ p.103)

## **CONTENTS**
1. **데이터형**<a href = "#%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%98%95"><sup>[1]</sup></a>
    - C++에 내장된 데이터형<a href = "#c에-내장된-데이터형"><sup>[1.1]</sup></a>
1. **정수형**<a href = "#%EC%A0%95%EC%88%98%ED%98%95"><sup>[2]</sup></a>
    - 정수형의 종류<a href = "#정수형의-종류"><sup>[2.1]</sup></a>
    - 정수크기 계산 방법<a href = "#정수크기-계산-방법"><sup>[2.2]</sup></a>
      - `sizeof` 와 `climits`
    - 초기화<a href = "#초기화"><sup>[2.3]</sup></a>
      - Overflow/Underflow
    - 상수<a href = "#상수"><sup>[2.4]</sup></a>
      - 정수값을 16진수나 8진수로 출력하려면?
      - C++가 상수의 데이터형을 결정하는 방법
1. **Char 형**
    - 아스키 코드(ASCII Code)
    - 맴버 함수: ```cout.put()```
      - class와 OOP의 개념 정리
    - 상수
    - 유니버설 네임 코드
    - `Unicode`와 `ISO 10646`
    - 확장 char형: `wchar_t`
    - 새로운 C++11형: `char16_t`와 `char32_t`
 1. **Bool 형**
 1. **const 제한자**
 
   
---

**데이터형**
---
`자료형(Data Type)`은 **'일정 크기의 메모리에 저장된 정보를 해석하는 방법'** 이다.

#### C++에 내장된 데이터형

- C++에 내장된 데이터형에는 **기본형**과 **복합형**이 있다.
- C와 비교해봤을 때 복합형을 제외한 기본형은 크게 다르지 않다.
- **기본형**
  1. 정수를 포현할 수 있는 `정수형`
  1. 소수부가 있는 수를 표현할 수 있는 `부동 소수점형`
- **복합형**
  - 배열, 문자열, 포인터, 구조체, 클래스, etc.

C++11 표준에서는 몇몇 자료형이 새롭게 추가되었다.

| 자료형 | 설명 |
| --- | --- |
| long | 64비트 정수(컴파일러에 따라 약간 다를 수 있음 |
| char16_t | 16비트 문자(ex. char16_t a = u'A';) |
| char32_t | 32비트 문자(ex. char32_t a = u'A';) |
| auto     | 컴파일러가 자동으로 형식을 규정하는 자료형(ex. auto a = 10;) |
| decltype(expr) | expr과 동일한 자료형(ex.int a(10); decltype(a)y = 20;) |

- `char16_t`와 `char32_t`는 **유니코드 처리를 위한 자료형**이다.
- `auto`의 경우 기존에 있던 자료형으로, 의미가 새롭게 바뀐 자료형이다.
    - **초기값의 형식에 맞춰 선언하는 인스턴스의 형식이 '자동'으로 결정된다.**
- 즉, `auto`나 `decltype(expr)`는 완전히 새로운 자료형이다. 



참고: <a href = "http://www.cplusplus.com/doc/tutorial/variables/">cplusplus.com</a>



**정수형**
---
`정수형`은 2, 98 등과 같이 소수부가 없는 수를 말한다.
컴퓨터의 메모리용량에는 한계가 있으므로 컴퓨터 언어는 정수들의 부분 집합만을 나타낼 수 있다.

#### 정수형의 종류
- C++에서는 프로그램에서 요구하는 특정 상황에 알맞은 정수형을 골라 사용할 수 있도록 여러 가지 정수형을 제공한다.
- 폭(width, 정수 저장 시 사용되는 메모리 크기)에 따라 크기 순서대로 나열하자면 다음과 같다.
    - char
    - short
    - int 
    - long
    - long long (C++11)

| NOTE: `int`형은 컴퓨터가 가장 효율적으로 처리하는 정수 형식이다. |
| ---|

#### 정수크기 계산 방법
C++ 시스템의 정수 크기가 얼마인지 알고 싶으면, 데이터형의 크기를 알아내는 C++의 도구를 사용할 수 있다.

##### 1. `sizeof`연산자
- `sizeof`연산자를 사용하면 변수나 데이터형의 크기를 바이트 단위로 리턴받아 데이터형의 크기를 알 수 있다.
```cpp
int n_int = 10;

std::cout << sizeof(int) << endl;
std::cout << sizeof n_int << endl;
```
-  `sizeof`연산자는 `int`와 같은 데이터형 이름에 사용할 때는 괄호를 사용해야 하며, `n_int`와 같은 변수이름에는 괄호가 없어도 상관없다.

##### 2. `climits` 헤더파일
- 2번째 방법은 여러 가지 정수형들의 범위에 대한 정보가 들어 있는 `climits`헤더 파일을 열어 보는 것이다.
```cpp
#include <iostream>
#include <climits>

int main(void) {
    
    int n_int = INT_MAX;
    std::cout << n_int << std::endl;
    std::cout << "char의 비트수 = " << CHAR_BIT << std::endl;   //CHAR_BIT: char형의 비트수를 정의
    
    // INT_MIN, SHRT_MAX, LONG_MAX, LLONG_MAX.. 등 각 데이터형의 최대, 최소값 등이 들어 있음

    return 0;
}
```
-  `sizeof`연산자는 `int`와 같은 데이터형 이름에 사용할 때는 괄호를 사용해야 하며, `n_int`와 같은 변수이름에는 괄호가 없어도 상관없다.

#### 초기화
##### 1. 기존의 방식
```c
int owls = 10;
```
##### 2. C++의 초기화 문법
```cpp
int wrens(432); // C++의 새로운 초기화 문법, wrens를 432로 초기화
```
##### 3. C++11에서의 초기화
```cpp
int hamburger = {24}; // hamburger를 24로 초기화
int emus{ 7 };        // =를 사용할 수도, 사용하지 않을 수도 있다. 
int rheas = { 12 };
int psychics{ }; // psychics를 0으로 초기화
```

##### 4. Overflow/Underflow In C++
- C++에서 자료형이 표현할 수 있는 한계를 벗어나면 그 표현 버위의 반대편에서부터 다시 시작한다.
- C++는 표현 한계값을 벗어날 때 (Overflow/Underflow 발생 시) `unsigned` 정수형의 경우 '0' 또는 최대값으로 바뀌며,
`signed` 정수형의 경우 최소값 또는 최대값으로 바뀐다.

#### 상수
`정수형 상수`는 212, 116과 같이 프로그램에 직접 써 넣는 정수를 말한다.
C++에서 프로그램에 쓸 수 있는 상수는 크게 **8진수**, **10진수**, **16진수**가 있다.

##### 1. 정수값을 16진수나 8진수로 출력하려면?
- 정수값을 16진수나 8진수로 출력하려면 `cout`의 특별한 기능을 사용해야 한다.
- `iostream`헤더 파일은 정수를 8진수, 10진수, 16진수로 각각 출력하라는 메세지를 `cout`에 전달하는 **`dec`**, **`hex`**, **`oct`** 조정자를 제공한다. (10진수가 default이다.)
```c
//10진수
std::cout << 15 << '\n';

//8진수
std::cout << std::oct;
std::cout << 15 << '\n';    //17

//16진수
std::cout << std::hex;
std::cout << 15 << '\n';    //f
```
- **`std::cout << std::oct`** 와 같은 코드는 화면에 아무것도 출력하지 않는다.
- 즉, 이 코드는 **cout가 정수를 디스플레이하는 방식을 변경**한다.

##### 2진수 출력하는 방법

###### 1. `<bitset>` 헤더파일 이용
```c
#include <bitset>

int main(void) {

	//변수 선언 후 출력
	std::bitset<8> ch_bits = 15;
	std::cout << ch_bits << '\n';

	//형 변환 후 출력
	std::cout << (class std::bitset<CHAR_BIT>)15 << '\n';
}
```
###### 직접 함수 만들기 
```cpp
void Dec_To_Bin(int n, size_t size)
{
	for (int i = size - 1; i >= 0; i--)
	{
		int k = n >> i;

		if (k & 1)
			std::cout << "1";
		else
			std::cout << "0";
		
		//space per 'x4'
		if (i != 0 && !(i % 4))
			std::cout << ' ';
	}
	std::cout << '\n';
}
```

##### 2. C++가 상수의 데이터형을 결정하는 방법
- **C++은 특별한 이유가 없다면 정수형 상수를 모두 `int` 형으로 저장한다.**
- 즉, 아래와 같은 경우가 예외의 경우이다.
    - 특정 데이터형을 의미하는 접미어를 상수에 붙였을 때
    - 값이 너무 커서 `int`형으로 저장할 수 없을 때
 - 접미어
    1. `l, L` --> `long`형
    1. 'u, U' --> `unsigned int`형
    1. `ul` --> `unsigned long`형
    1. `ll, LL` --> `unsinged long long`형 
 - 접미어가 없는 10진 정수는 `int`, `long`, `long long`형 중에서 크기가 가장 작은 것으로 나타낸다.
 
